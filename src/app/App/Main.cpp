#include "Core/NesCpu.hpp"
#include <SDL.h>
#include <SDL_keycode.h>
#include <SDL_pixels.h>
#include <chrono>
#include <iostream>
#include <array>
#include <random>
#include <thread>

SDL_Color color(uint8_t byte) {
  SDL_Color result;
  switch (byte) {
  case 0:
    result = {0x00, 0x00, 0x00, 0xFF}; // BLACK
    break;
  case 1:
    result = {0xFF, 0xFF, 0xFF, 0xFF}; // WHITE
    break;
  case 2:
  case 9:
    result = {0x80, 0x80, 0x80, 0xFF}; // GREY
    break;
  case 3:
  case 10:
    result = {0xFF, 0x00, 0x00, 0xFF}; // RED
    break;
  case 4:
  case 11:
    result = {0x00, 0xFF, 0x00, 0xFF}; // GREEN
    break;
  case 5:
  case 12:
    result = {0x00, 0x00, 0xFF, 0xFF}; // BLUE
    break;
  case 6:
  case 13:
    result = {0xFF, 0x00, 0xFF, 0xFF}; // MAGENTA
    break;
  case 7:
  case 14:
    result = {0xFF, 0xFF, 0x00, 0xFF}; // YELLOW
    break;
  default:
    result = {0x00, 0xFF, 0xFF, 0xFF}; // CYAN
    break;
  }
  return result;
}

bool read_screen_state(NesCpu *cpu, uint8_t frame[32 * 3 * 32]) {
  int frame_idx = 0;
  bool update = false;
  for (int i = 0x0200; i < 0x600; i++) {
    uint8_t color_idx = cpu->mem_read(i);
    SDL_Color c = color(color_idx);
    if (frame[frame_idx] != c.r || frame[frame_idx + 1] != c.g ||
        frame[frame_idx + 2] != c.b) {
      frame[frame_idx] = c.r;
      frame[frame_idx + 1] = c.g;
      frame[frame_idx + 2] = c.b;
      update = true;
    }
    frame_idx += 3;
  }
  return update;
}

void handle_user_input(NesCpu &cpu, SDL_Event &event) {
  while (SDL_PollEvent(&event)) {
    switch (event.type) {
    case SDL_QUIT:
    case SDL_KEYDOWN:
      if (event.key.keysym.sym == SDLK_ESCAPE) {
        std::exit(0);
      } else if (event.key.keysym.sym == SDLK_w) {
        cpu.mem_write(0xff, 0x77);
      } else if (event.key.keysym.sym == SDLK_s) {
        cpu.mem_write(0xff, 0x73);
      } else if (event.key.keysym.sym == SDLK_a) {
        cpu.mem_write(0xff, 0x61);
      } else if (event.key.keysym.sym == SDLK_d) {
        cpu.mem_write(0xff, 0x64);
      }
      break;
    default:
      break;
    }
  }
}

int main(int argc, char *argv[]) {
  SDL_Init(SDL_INIT_VIDEO);
  SDL_Window *window =
      SDL_CreateWindow("Snake game", SDL_WINDOWPOS_CENTERED,
                       SDL_WINDOWPOS_CENTERED, 320, 320, SDL_WINDOW_SHOWN);
  SDL_Renderer *renderer = SDL_CreateRenderer(
      window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);

  SDL_RenderSetScale(renderer, 10.0, 10.0);

  SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGB24,
                                           SDL_TEXTUREACCESS_TARGET, 32, 32);

  SDL_Event event;
  SDL_zero(event);


  std::vector<uint8_t> game_code = {
      0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06,
      0x60, 0xa9, 0x02, 0x85, 0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85,
      0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85, 0x14, 0xa9, 0x04, 0x85,
      0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
      0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20,
      0x8d, 0x06, 0x20, 0xc3, 0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20,
      0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9, 0x77, 0xf0, 0x0d, 0xc9,
      0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
      0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9,
      0x08, 0x24, 0x02, 0xd0, 0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01,
      0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02, 0x60, 0xa9, 0x02, 0x24,
      0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
      0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01,
      0xc5, 0x11, 0xd0, 0x07, 0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60,
      0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06, 0xb5, 0x11, 0xc5, 0x11,
      0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
      0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca,
      0x10, 0xf9, 0xa5, 0x02, 0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0,
      0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9, 0x20, 0x85, 0x10, 0x90,
      0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
      0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69,
      0x20, 0x85, 0x10, 0xb0, 0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11,
      0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29, 0x1f, 0xc9, 0x1f, 0xf0,
      0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
      0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10,
      0x60, 0xa6, 0xff, 0xea, 0xea, 0xca, 0xd0, 0xfb, 0x60,
  };

  NesCpu *cpu = new NesCpu();
  cpu->load(game_code);
  cpu->reset();

  uint8_t screen_state[32 * 3 * 32];
  std::mt19937 rng(std::random_device{}());

  cpu->run_with_callback([&event, &rng, &screen_state, &texture, &renderer](NesCpu& cpu) {
    handle_user_input(cpu, event);
    cpu.mem_write(0xfe, rng() % 15 + 1);

    if(read_screen_state(&cpu, screen_state)) {
      SDL_UpdateTexture(texture, nullptr, screen_state, 32 * 3);
      SDL_RenderCopy(renderer, texture, nullptr, nullptr);
      SDL_RenderPresent(renderer);
    }

    std::this_thread::sleep_for(std::chrono::microseconds(70));
  });
  return 0;
}
